<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Озеро Светлое</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				text-align:center;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="info">Озеро Светлое - прибрежная территория</div>

		<script src="../build/three.min.js"></script>

		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/Mirror.js"></script>
		<script src="js/WaterShader.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJMTLLoader.js"></script>
		
		<!-- ShaderParticles -->
		<script type="text/javascript" src="js/ShaderParticleEngine/ShaderParticleUtils.js"></script>
		<script type="text/javascript" src="js/ShaderParticleEngine/ShaderParticleGroup.js"></script>
		<script type="text/javascript" src="js/ShaderParticleEngine/ShaderParticleEmitter.js"></script>	

		<script src="js/controls/EventsControls.js"></script>		
	
		<script>


			THREE.Path.prototype.moveToVector = function ( vector ) {

				this.moveTo( vector.x, vector.y );

			};

			THREE.Path.prototype.lineToVector = function ( vector ) {

				this.lineTo( vector.x, vector.y );

			};
					
		
			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;
			var camera, scene, renderer;
			var plane;

			var californiaPts = [], vectors=[];
			var MapGeometry;

				var scale = 20;
				var sqWidth = scale * 1024; 
				var sqHight = scale * 1024;			
			
			        // Used in initParticles()
			var emitter, particleGroup;
			var clock = new THREE.Clock();
			var tree;
			var parameters = {
				width: 2000,
				height: 2000,
				widthSegments: 250,
				heightSegments: 250,
				depth: 1500,
				param: 4,
				filterparam: 1
			}
			
			var waterNormals;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.5, 3000000 );
				camera.position.set( -4000, 4000, 12000 );

				//camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
				//camera.position.z = 50;
				//camera.lookAt( scene.position );
			
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.userPan = false;
				controls.userPanSpeed = 0.0;
				controls.maxDistance = 25000.0;
				controls.maxPolarAngle = Math.PI * 0.495;
				controls.center.set( 0, 500, 0 );

				var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
				light.position.set( - 1, 1, - 1 );
				scene.add( light );

				var light = new THREE.DirectionalLight( 0xffffff, 0.5 );
				light.position.set( - 1000, 10000, - 10000 );
				//scene.add( light );				
				
				
				//------------------ load skybox ------------------ //

				
				var cubeMap = new THREE.CubeTexture( [] );
				cubeMap.format = THREE.RGBFormat;
				cubeMap.flipY = false;

				var loader = new THREE.ImageLoader();
				loader.load( 'textures/skyboxsun25degtest.png', function ( image ) {

					var getSide = function ( x, y ) {

						var size = 1024;

						var canvas = document.createElement( 'canvas' );
						canvas.width = size;
						canvas.height = size;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, - x * size, - y * size );

						return canvas;

					};

					cubeMap.images[ 0 ] = getSide( 2, 1 ); // px
					cubeMap.images[ 1 ] = getSide( 0, 1 ); // nx
					cubeMap.images[ 2 ] = getSide( 1, 0 ); // py
					cubeMap.images[ 3 ] = getSide( 1, 2 ); // ny
					cubeMap.images[ 4 ] = getSide( 1, 1 ); // pz
					cubeMap.images[ 5 ] = getSide( 3, 1 ); // nz
					cubeMap.needsUpdate = true;

				} );

				var cubeShader = THREE.ShaderLib['cube'];
				cubeShader.uniforms['tCube'].value = cubeMap;

				var skyBoxMaterial = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader.fragmentShader,
					vertexShader: cubeShader.vertexShader,
					uniforms: cubeShader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				});

				var skyBox = new THREE.Mesh(
					new THREE.BoxGeometry( 1000000, 1000000, 1000000 ),
					skyBoxMaterial
				);
				
				scene.add( skyBox );


				//------------------ load bright lake ------------------ //
				
				
				waterNormals = new THREE.ImageUtils.loadTexture( 'textures/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 

				water = new THREE.Water( renderer, camera, scene, {
					textureWidth: 512, 
					textureHeight: 512,
					waterNormals: waterNormals,
					alpha: 	1.0,
					sunDirection: light.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 50.0,
				} );


				// California



					vectors[0] = new THREE.Vector3(234,-236,0);
					vectors[1] = new THREE.Vector3(240,-218,0);
					vectors[2] = new THREE.Vector3(250,-200,0);
					vectors[3] = new THREE.Vector3(256,-171,0);
					vectors[4] = new THREE.Vector3(267,-149,0);
					vectors[5] = new THREE.Vector3(258,-127,0);
					vectors[6] = new THREE.Vector3(234,-107,0);
					vectors[7] = new THREE.Vector3(207,-87,0);
					vectors[8] = new THREE.Vector3(182,-69,0);
					vectors[9] = new THREE.Vector3(162,-47,0);
					vectors[10] = new THREE.Vector3(143,-42,0);
					vectors[11] = new THREE.Vector3(129,-38,0);
					vectors[12] = new THREE.Vector3(123,-25,0);
					vectors[13] = new THREE.Vector3(102,-9,0);
					vectors[14] = new THREE.Vector3(80,2,0);
					vectors[15] = new THREE.Vector3(69,11,0);
					vectors[16] = new THREE.Vector3(56,27,0);
					vectors[17] = new THREE.Vector3(36,29,0);
					vectors[18] = new THREE.Vector3(7,29,0);
					vectors[19] = new THREE.Vector3(-20,31,0);
					vectors[20] = new THREE.Vector3(-42,33,0);
					vectors[21] = new THREE.Vector3(-64,40,0);
					vectors[22] = new THREE.Vector3(-83,54,0);
					vectors[23] = new THREE.Vector3(-91,74,0);
					vectors[24] = new THREE.Vector3(-94,96,0);
					vectors[25] = new THREE.Vector3(-78,116,0);
					vectors[26] = new THREE.Vector3(-64,138,0);
					vectors[27] = new THREE.Vector3(-51,154,0);
					vectors[28] = new THREE.Vector3(-58,174,0);
					vectors[29] = new THREE.Vector3(-80,182,0);
					vectors[30] = new THREE.Vector3(-98,180,0);
					vectors[31] = new THREE.Vector3(-114,187,0);
					vectors[32] = new THREE.Vector3(-134,174,0);
					vectors[33] = new THREE.Vector3(-151,156,0);
					vectors[34] = new THREE.Vector3(-171,133,0);
					vectors[35] = new THREE.Vector3(-182,113,0);
					vectors[36] = new THREE.Vector3(-196,91,0);
					vectors[37] = new THREE.Vector3(-194,67,0);
					vectors[38] = new THREE.Vector3(-200,38,0);
					vectors[39] = new THREE.Vector3(-203,7,0);
					vectors[40] = new THREE.Vector3(-196,-13,0);
					vectors[41] = new THREE.Vector3(-189,-33,0);
					vectors[42] = new THREE.Vector3(-169,-54,0);
					vectors[43] = new THREE.Vector3(-147,-80,0);
					vectors[44] = new THREE.Vector3(-113,-98,0);
					vectors[45] = new THREE.Vector3(-80,-113,0);
					vectors[46] = new THREE.Vector3(-47,-113,0);
					vectors[47] = new THREE.Vector3(-15,-107,0);
					vectors[48] = new THREE.Vector3(15,-114,0);
					vectors[49] = new THREE.Vector3(44,-125,0);
					vectors[50] = new THREE.Vector3(67,-138,0);
					vectors[51] = new THREE.Vector3(91,-149,0);
					vectors[52] = new THREE.Vector3(113,-169,0);
					vectors[53] = new THREE.Vector3(133,-183,0);
					vectors[54] = new THREE.Vector3(145,-200,0);
					vectors[55] = new THREE.Vector3(163,-207,0);
					vectors[56] = new THREE.Vector3(182,-223,0);
					vectors[57] = new THREE.Vector3(200,-234,0);
					vectors[58] = new THREE.Vector3(218,-238,0);

				for ( var i = 0; i < vectors.length; i++ ) {

					californiaPts.push( vectors[i] );

				}				


				for( var i = 0; i < californiaPts.length; i ++ ) californiaPts[ i ].multiplyScalar( 1.5*scale );

				var californiaShape = new THREE.Shape( californiaPts );
					//var geometry = new THREE.ShapeGeometry( californiaShape );
					//var mirrorMesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } ) );
					
					//mirrorMesh.position.set( 0, 0, 0 );
					//mirrorMesh.rotation.x = -Math.PI/2;
					//mirrorMesh.rotation.z = -Math.PI/2;					

				var extrMaterial = new THREE.MeshBasicMaterial({
						color: 0xffffff,
						side: THREE.DoubleSide
				});				

				var extrudeSettings = { 
					amount: 1, 
					bevelSegments: 1, 
					curveSegments: 32, 
					material: 0, 
					extrudeMaterial: 1 
				};

				var geometry = new THREE.ExtrudeGeometry( californiaShape, extrudeSettings );
				water.material.transparent = false;
				var materials = [water.material, extrMaterial];
				var material = new THREE.MeshFaceMaterial(materials);
				
				//var material = new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide, transparent: false, opacity: 0.5 } );

				var mesh = new THREE.Mesh( geometry, material );

				mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( scale / 1.7 * 1024, scale / 1.7 * 1024 ),
					water.material
				);
				
				mirrorMesh.rotation.x = -Math.PI/2;
				mirrorMesh.position.set( 0, -420, -1500 );
				mirrorMesh.add( water );
				scene.add( mirrorMesh );				

							
				
				//mirrorMesh.add( water );
				//mirrorMesh.rotation.x = - Math.PI * 0.5
				//mirrorMesh.position.set( -4000, 20, 0 );
				//scene.add( mirrorMesh );


				MapGeometry = new THREE.PlaneBufferGeometry( scale*1024, scale*1024, 1024-1, 1024-1 );
				MapGeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
			
			var texture = THREE.ImageUtils.loadTexture( 'textures/city.png' );
						
			var material = new THREE.MeshLambertMaterial( { map: texture } );
			plane = new THREE.Mesh( MapGeometry, material );
			plane.position.set( 0, -640, 0 );		 
			
				
				
	var img = new Image();
		img.onload = function () {
		  
			//get height data from img
			var data = getHeightData(img);
		  
			// plane

				var vertices = MapGeometry.attributes.position.array;

				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {

					vertices[ j + 1 ] = data[ i ] * scale/2;

				}

				MapGeometry.computeFaceNormals();	
				scene.add(plane);		
		//	edges = new THREE.FaceNormalsHelper( plane, 200, 0x00ff00, 1 ); scene.add( edges );
		   
		};
		// load img source
		img.src = "textures/cityheightmap2.png";
	


				
				//------------------ load Fountan ------------------ //				
			
			
			initParticles( -2000, -320, 300, 500 );
	
			var geometry = new THREE.TorusGeometry( 120, 80, 36, 36 );
			//	var material = new THREE.MeshPhongMaterial( { color: 0x00BFFF, shininess: 300 } );
				var material = new THREE.MeshPhongMaterial( { color: 0xA0522D, shininess: 300 } );			
				var disk = new THREE.Mesh( geometry, material );
					disk.rotation.x = Math.PI / 2;
					disk.position.set( -2000, -350, 300 );
					scene.add( disk );

	
				//------------------ load volleyball ------------------ //	
			var geometry = new THREE.Geometry;
			var material = new THREE.LineBasicMaterial( { color: 0x8B4726 } );

			geometry.vertices.push( new THREE.Vector3( -1000, 0, 0 ) ); 
			geometry.vertices.push( new THREE.Vector3( -1000, 500, 0 ) ); 
			geometry.vertices.push( new THREE.Vector3( 1000, 500, 0 ) ); 			
			geometry.vertices.push( new THREE.Vector3( 1000, 0, 0 ) ); 
			geometry.vertices.push( new THREE.Vector3( 1000, 300, 0 ) ); 
			geometry.vertices.push( new THREE.Vector3( -1000, 300, 0 ) ); 
			
			var line = new THREE.Line( geometry, material );
			line.scale.x = 1/1.85;
			line.position.set( 4568, 0, -780 );
			line.rotation.y = Math.PI / 2.8;
			scene.add( line );

			
				//------------------ load GRID ------------------ //
				
			
			
			TdCount = 31.7; 
			TdLen = 20 * 1024 / TdCount;
			var gridLen = 10*1024;
      

            var gridXZ = new THREE.GridHelper( gridLen, TdLen );
            gridXZ.setColors(new THREE.Color(0xD3D3D3), new THREE.Color(0xD3D3D3));
            gridXZ.position.set(0, 0, 0);
            //scene.add(gridXZ);
			
				//------------------ Второстепенные здания ------------------ //			
			
			grayBuildings();
			
				//------------------ ------------------ //			
			

			
	///////////
	// VIDEO //
	///////////

				EventsControlsObj = new EventsControls( camera, renderer.domElement );
				EventsControlsObj.map = plane;
				


				EventsControlsObj.attachEvent( 'dragAndDrop', function () {

					this.container.style.cursor = 'move';
					this.focused.position.x = Math.round( ( this.focused.position.x ) / 10 ) * 10;
					this.focused.position.y = Math.round( ( this.focused.position.y ) / 10 ) * 10;					
					this.focused.position.z = Math.round( ( this.focused.position.z ) / 10 ) * 10;

					controls.enabled = false;
				});

				EventsControlsObj.attachEvent( 'mouseUp', function () {
					this.focused.position.y = this.focused.position.y + this.previous.y;
					console.log( this.focused.position );
					this.container.style.cursor = 'auto';
					controls.enabled = true;
					
				});
	
	
				EventsControls = new EventsControls( camera, renderer.domElement );

				EventsControls.attachEvent( 'onclick', function () {
				scene.getObjectByName( "key" + String( this.event.item ) ).position.z = 0;	
			
					if ( this.event.item == 0 )	video.play();
					if ( this.event.item == 1 )	video.pause();
					
					setTimeout( 'scene.getObjectByName( "key' + String( this.event.item ) + '" ).position.z = 20', 100 );

					
				});

	
	// create the video element
	video = document.createElement( 'video' );
	// video.id = 'video';
	// video.type = ' video/ogg; codecs="theora, vorbis" ';
	video.src = "videos/Selena Gomez & The Scene - Hit The Lights2_cut.mp4";
	video.load(); // must call after setting/changing source
	//video.play();
	
	// alternative method -- 
	// create DIV in HTML:
	// <video id="myVideo" autoplay style="display:none">
	//		<source src="videos/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
	// </video>
	// and set JS variable:
	// video = document.getElementById( 'myVideo' );
	
	videoImage = document.createElement( 'canvas' );
	videoImage.width = 480;
	videoImage.height = 320;

	videoImageContext = videoImage.getContext( '2d' );
	// background color if no video present
	videoImageContext.fillStyle = '#000000';
	videoImageContext.fillRect( 0, 0, videoImage.width, videoImage.height );

	videoTexture = new THREE.Texture( videoImage );
	videoTexture.minFilter = THREE.LinearFilter;
	videoTexture.magFilter = THREE.LinearFilter;
		//videoTexture.offset.set( 0.3, 0.1 );
	
	var movieMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: true } ); // , side:THREE.DoubleSide
	// the geometry on which the movie will be displayed;
	// 		movie image will be scaled to fit these dimensions.
	var koef = 5;
	var movieGeometry = new THREE.PlaneGeometry( 220 * koef, 120 * koef, 4, 4 );
	var movieScreen = new THREE.Mesh( movieGeometry, movieMaterial );
	movieScreen.position.set( -4980, 1000, -5520);
	
	//movieScreen.rotation.y = -Math.PI / 6;
	scene.add(movieScreen);
	
	var geometry = movieGeometry.clone();
	var material = new THREE.MeshPhongMaterial( { color: 0x000F00, side: THREE.BackSide} )
	var movieScreenBack = new THREE.Mesh( geometry, material );
	movieScreenBack.position.copy( movieScreen.position );
	movieScreenBack.rotation.y  =  movieScreen.rotation.y;
	scene.add(movieScreenBack);			
			
	var pedestalTV = new THREE.Object3D();
	var a = 5, b = 28, c = a + 23, d = b + 7;
					vectors[0] = new THREE.Vector3(a,0,0);
					vectors[1] = new THREE.Vector3(a,b,0);
					vectors[2] = new THREE.Vector3(c,b,0);
					vectors[3] = new THREE.Vector3(c,d,0);
					vectors[4] = new THREE.Vector3(-c,d,0);
					vectors[5] = new THREE.Vector3(-c,b,0);
					vectors[6] = new THREE.Vector3(-a,b,0);
					vectors[7] = new THREE.Vector3(-a,0,0);

					var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 8; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();
			
			var extrudeSettings = { 
					amount: 20, 
					bevelSegments: 8, 
					curveSegments: 32,
					bevelEnabled: false
				};
				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );	
				var mesh = new THREE.Mesh(geometry, material);

				//mesh.rotation.x = -Math.PI/2;
		mesh.position.z = -10;
		//mesh.position.y = -d * scale;			
		pedestalTV.add(mesh);			
		
			var material = new THREE.MeshLambertMaterial( { color: 0x3B3C3D } );	

		var Texture =  THREE.ImageUtils.loadTexture( "textures/button_black_play.png" );
			Texture.anisotropy = renderer.getMaxAnisotropy();		
		var material1 = new THREE.MeshLambertMaterial( { map: Texture } );	

		var mesh = new CylindricalMesh( 65, 30, 36, 1, [ material1, material ] );
		mesh.name = 'key' + String( 0 );
		mesh.rotation.x = Math.PI/2;	
		mesh.position.set( -130, 625, 20 ); 		
		pedestalTV.add( mesh );
		
		mesh.name = 'key' + String( 0 );
		//EventsControls.attach( mesh );	

		var Texture =  THREE.ImageUtils.loadTexture( "textures/button_black_pause.png" );
			Texture.anisotropy = renderer.getMaxAnisotropy();			
		var material1 = new THREE.MeshLambertMaterial( { map: Texture } );	

		var mesh = new CylindricalMesh( 65, 30, 36, 1, [ material1, material ] );
		mesh.rotation.x = Math.PI/2;	
		mesh.position.set( 130, 625, 20 ); 

		pedestalTV.add( mesh );

		mesh.name = 'key' + String( 1 );
		//EventsControls.attach( mesh );		
		
		pedestalTV.position.copy( movieScreen.position );
		pedestalTV.position.y = 0;
		pedestalTV.rotation.y  =  movieScreen.rotation.y;	
		scene.add( pedestalTV );					
		

/*
	
            // Update cube map once the texture is loaded
            // to avoid extra payload when updating it on each frame
            treeTexture = THREE.ImageUtils.loadTexture(
                'textures/tree.png'
            );

            var tree = new THREE.Sprite(new THREE.SpriteMaterial({
                map: treeTexture,
                useScreenCoordinates: false
            }));
			
			tree.scale.set(1000, 1000, 1);
            tree.position.set(-9000, 400, 10000);
            scene.add(tree);
			
			for (var i=0; i<5; i++) {
				for (var j=0; j<5-i; j++) {
				
					var mesh = tree.clone();
					mesh.position.set(-9000+1000*i, 400, 10000 - 1000 * j);
					scene.add(mesh);			
				}
			}
			
			var pos = []; 
				for (var i=0; i<5; i++) {	
				
						var vector = new THREE.Vector3( -6000, 300, -5500 + 1000 * i );
						pos.push( vector );
				
				}			

				for (var i=0; i<5; i++) {	
				
						var vector = new THREE.Vector3( -7000, 300, -5500 + 1000 * i ); 
						pos.push( vector );
				}
				
				for (var i=0; i<3; i++) {	
				
						var vector = new THREE.Vector3( -6000, 300, 1500 + 1000 * i ); 
						pos.push( vector );
				}	
				
				for (var i=0; i<2; i++) {	
				
						var vector = new THREE.Vector3( -7000, 300, 1500 + 1000 * i ); 
						pos.push( vector );
				}

				for (var i=0; i<3; i++) {	
				
						var vector = new THREE.Vector3( -5000, 300, 2500 + 1000 * i ); 
						pos.push( vector );
				}
				
				for (var i=0; i<3; i++) {	
				
						var vector = new THREE.Vector3( -4000, 300, 3250 + 1000 * i ); 
						pos.push( vector );
				}	
				
				for (var i=0; i<3; i++) {	
				
						var vector = new THREE.Vector3( -3000, 300, 3750 + 1000 * i ); 
						pos.push( vector );
				}					
				
				for (var i=0; i<pos.length; i++) {
				
						var mesh = tree.clone();
						mesh.position.copy(pos[i]);
						scene.add(mesh);			

				}	
	
		
*/



					vectors[0] = new THREE.Vector3(-39,-126,0);
					vectors[1] = new THREE.Vector3(-68,-127,0);
					vectors[2] = new THREE.Vector3(-94,-123,0);
					vectors[3] = new THREE.Vector3(-115,-110,0);
					vectors[4] = new THREE.Vector3(-138,-97,0);
					vectors[5] = new THREE.Vector3(-158,-81,0);
					vectors[6] = new THREE.Vector3(-177,-68,0);
					vectors[7] = new THREE.Vector3(-192,-50,0);
					vectors[8] = new THREE.Vector3(-202,-27,0);
					vectors[9] = new THREE.Vector3(-213,-5,0);
					vectors[10] = new THREE.Vector3(-215,23,0);
					vectors[11] = new THREE.Vector3(-213,46,0);
					vectors[12] = new THREE.Vector3(-208,66,0);
					vectors[13] = new THREE.Vector3(-205,91,0);
					vectors[14] = new THREE.Vector3(-193,114,1);
					vectors[15] = new THREE.Vector3(-183,134,3);
					vectors[16] = new THREE.Vector3(-168,153,3);
					vectors[17] = new THREE.Vector3(-152,174,4);
					vectors[18] = new THREE.Vector3(-135,192,5);
					vectors[19] = new THREE.Vector3(-113,203,5);
					vectors[20] = new THREE.Vector3(-96,191,4);
					vectors[21] = new THREE.Vector3(-70,191,5);
					vectors[22] = new THREE.Vector3(-52,181,5);
					vectors[23] = new THREE.Vector3(-39,168,5);
					
				var arrSpline = [];
				var material = new THREE.MeshLambertMaterial( { 
						color: 0x9b2d30,
				} );				
				for ( var i = 0; i < 24; i++ ) {

					var vector = vectors[i].clone().multiplyScalar( scale );
					arrSpline.push( vector );
					var Cube = new THREE.Mesh( new THREE.BoxGeometry( 30, 300, 30 ), material );
					Cube.position.set( vector.x, vector.z - 300-50, -vector.y );
					scene.add( Cube );	
				}		
	
	
	var jsonLoader = new THREE.JSONLoader();
	jsonLoader.load( "models/trees/tree.js", function( geometry, materials ) {
			var material = new THREE.MeshFaceMaterial( materials );
			tree = new THREE.Mesh( geometry, material );
			tree.scale.set(100,100,100);
			tree.position.set( 3000, 0, -3000 );	

	var spriteMaterial = new THREE.SpriteMaterial( 
	{ 
		map: new THREE.ImageUtils.loadTexture( 'textures/tree3.png' ), 
		useScreenCoordinates: false, 
		color: 0x0A2A0A, transparent: true, opacity: 0.8//, blending: THREE.AdditiveBlending
	});
	var sprite = new THREE.Sprite( spriteMaterial );
	sprite.position.y = 3.5;
	sprite.scale.set(4, 4, 1.0);
	tree.add(sprite); // this centers the glow at the mesh

scene.add( tree ); 

				for ( var i = 0; i < 24; i++ ) {

					var vector = vectors[i].clone().multiplyScalar( scale );

					var tree2 = tree.clone();
					var vector = new THREE.Vector3( vector.x, vector.z - 300, -vector.y );				
					tree2.position.copy( vector.multiplyScalar( 1.1 ) );	
					scene.add( tree2 ); 
					
				}	
		});

	
				spline = new THREE.SplineCurve3( arrSpline );
				var tubegeo = new THREE.TubeGeometry( spline, 128, 20, 12 );

				
				var tube = new THREE.Mesh( tubegeo, material );
				tube.position.set( 0, -200, 0 );	
				scene.add( tube );		
				tube.rotation.x = -Math.PI/2;
		
				var Vectors = [];
					Vectors[0] = new THREE.Vector3(-211,309,0);
					Vectors[1] = new THREE.Vector3(-125,253,0);
					Vectors[2] = new THREE.Vector3(-109,246,0);
					Vectors[3] = new THREE.Vector3(-93,245,0);
					Vectors[4] = new THREE.Vector3(-78,252,0);
					Vectors[5] = new THREE.Vector3(-67,262,0);
					Vectors[6] = new THREE.Vector3(28,407,0);
					Vectors[7] = new THREE.Vector3(38,393,0);
					Vectors[8] = new THREE.Vector3(55,386,0);
					Vectors[9] = new THREE.Vector3(73,381,0);
					Vectors[10] = new THREE.Vector3(91,372,0);
					Vectors[11] = new THREE.Vector3(109,365,0);
					Vectors[12] = new THREE.Vector3(129,358,0);
					Vectors[13] = new THREE.Vector3(142,348,0);

			for ( var i = 0; i < Vectors.length; i++ ) {
				
				Vectors[i].multiplyScalar( scale );
				Vectors[i].y = - Vectors[i].y;
			}
					
				var H = 250; var sizeX = 256; var count = 12;
				prism( Vectors, H, sizeX, count, 'textures/zabor3.png', true, 0.99, 110 );	
	
	

	
				var H = 250; var sizeX = 256; var count = 12;
				prism( [ 
				
					new THREE.Vector3(142,-348,0).multiplyScalar( scale ),
					new THREE.Vector3(75,-223,0).multiplyScalar( scale ),
					new THREE.Vector3(392,-45,0).multiplyScalar( scale ),
					new THREE.Vector3(467,-161,0).multiplyScalar( scale )				

					]
					, H, sizeX, count, 'textures/zabor44.png', true, 0.99, 110 );		
	
				var Arra = [
					new THREE.Vector3(-206,32,0).multiplyScalar( scale ),
					new THREE.Vector3(-185,15,0).multiplyScalar( scale ),
					new THREE.Vector3(-164,43,0).multiplyScalar( scale ),
					new THREE.Vector3(-186,59,0).multiplyScalar( scale )				

					];	
	
				var H = 200; var sizeX = 256; var count = 3;
				prism( Arra, H, sizeX, count, 'textures/zabor5.png', true, 0.99, -180 );			
				
				var H = 200; var sizeX = 256; var count = 4;	
				prism( Arra, H, sizeX, count, 'textures/zabor6.png', true, 0.99, -390 );		
	
				for ( var i = 0; i < 4; i++ ) {
					Arra[i].y = -Arra[i].y;
				}
				
				var shape = new THREE.Shape(); 
				shape.moveToVector( Arra[0] );
				
				for ( var i = 1; i < 4; i++ ) {

					shape.lineToVector( Arra[i] );
				}
						shape.closePath();
				

					
				var heightShore = 40, amount = 20;
				var extrudeSettings = { 
					amount: amount, 
					bevelSegments: 8, 
					curveSegments: 32,
					bevelEnabled: false
				};
				
				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );			
				var mesh = new THREE.Mesh(geometry, material);
				mesh.rotation.x = -Math.PI/2;
				mesh.position.y = -300;
				scene.add(mesh);
	
	
	
	
				//------------------ load exterior ------------------ //			
			
	
			
			
			var loader = new THREE.OBJMTLLoader(); // лоадер

			
			loader.load( 'models/bench/Bench3.obj', 'models/bench/Bench3.mtl', 
				function ( Bench3 ) {
			var material = new THREE.MeshLambertMaterial( { color: 0x8B4513 } );	

				Bench3.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							//child.material.map = texture;
							child.material = material;
						}

					} );
			
					Bench3.scale.set(1/5, 1/5, 1/5);
					Bench3.material = material;
					var urn = urn_add();
					Bench3.add(	urn );
					urn.position.set( -1100, -1070, 0 );
					Bench3.position.set( -20, 220-18, -2170 );	
					Bench3.rotation.y = Math.PI/2+Math.PI/3;	
					scene.add( Bench3 );
				//EventsControlsObj.attach( Bench3 );					
					
					var mesh = Bench3.clone();
					scene.add( mesh );
					mesh.position.set( 1520, 220-60, -1420 );
				//EventsControlsObj.attach( mesh );

					var mesh = Bench3.clone();
					scene.add( mesh );
					mesh.position.set( 2610, 220-50, -800 );
				//EventsControlsObj.attach( mesh );

					var mesh = Bench3.clone();
					scene.add( mesh );
					mesh.position.set( 3830, 220-30, -90 );
				//EventsControlsObj.attach( mesh );
					
					var mesh = Bench3.clone();
					scene.add( mesh );
					mesh.position.set( 5250, 220-16, 930 );
				//EventsControlsObj.attach( mesh );				
				
				}
			);
	
			//var urn = urn_add();
			//urn.position.set( -20, 200-20, -2170 );
			//scene.add( urn ); 
			//EventsControlsObj.attach( urn );		

			//addLine( -30,  -140, -2130 );

			//addLine( 1480, -200, -1420 );

			//addLine( 2540, -250, -850 );
			
			//addLine( 3620, 60, -220 );
			
			//addLine( 5130, 60, 940 );	


	

			
/*
			loader.load( 'models/outdoorBench/outdoorBench.obj', 'models/outdoorBench/outdoorBench.mtl', 
				function ( outdoorBench ) {
					outdoorBench.scale.set(2/3, 2/3, 2/3);
					outdoorBench.position.set( 1000, 0, -1000 );
					//outdoorBench.rotation.y = Math.PI+Math.PI/3;					
					scene.add( outdoorBench );				
				}
			);		
				
							
								loader.load( 'models/outdoorBench/outdoorBench.obj', 'models/outdoorBench/outdoorBench.mtl', 
									function ( outdoorBench ) {
										outdoorBench.scale.set(2, 2, 2);
										outdoorBench.position.set( 2000, 0, -500 );
										outdoorBench.rotation.y = Math.PI+Math.PI/3;					
										scene.add( outdoorBench );

										var mesh = outdoorBench.clone();
										scene.add( mesh );
										mesh.position.set( 3000, 0, 0 );

										var mesh = outdoorBench.clone();
										scene.add( mesh );
										mesh.position.set( 4000, 0, 500 );	

										var mesh = outdoorBench.clone();
										scene.add( mesh );
										mesh.position.set( 5000, 0, 1000 );
										
									}
								);		
					
					
					
					
							loader.load( 'models/arbor/arbor.obj', 'models/arbor/arbor.mtl', 
								function ( arbor ) {
									arbor.position.set( -500, 0, -1500 );	
									scene.add( arbor );
								}
							);
						*/
	/*		
			loader.load( 'models/arbor/arbor2.obj', 'models/arbor/arbor2.mtl', 
				function ( arbor2 ) {
			var material = new THREE.MeshLambertMaterial( { color: 0x8B4513 } );					
					arbor2.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							//child.material.map = texture;
							child.material = material;
						}

					} );			
				
					arbor2.scale.set(1/20, 1/20, 1/20);
					arbor2.position.set( -500, 1, -1500 );			
					scene.add( arbor2 );			
				}
			);

			
			loader.load( 'models/tent/tent.obj', 'models/tent/tent.mtl', 
				function ( tent ) {
					tent.scale.set(3, 3, 3);
					tent.position.set( -1500, 300, -2000 );			
					scene.add( tent );
				}
			);	

	
	
			loader.load( 'models/tree/tree11111.obj', 'models/tree/tree11111.mtl', 
				function ( tree ) {
					tree.scale.set(2, 2, 2);
					tree.position.set( -3000, 0, -2000 );			
					scene.add( tree );			
				}
			);		
		
			
	
			loader.load( 'models/tree/tree11112.obj', 'models/tree/tree11112.mtl', 
				function ( tree ) {
					tree.scale.set(2, 2, 2);
					tree.position.set( -7000, 0, -2000 );			
					scene.add( tree );			
				}
			);		
		
			loader.load( 'models/tree/tree11113.obj', 'models/tree/tree11113.mtl', 
				function ( tree ) {
					tree.scale.set(2, 2, 2);
					tree.position.set( -8000, 0, -2000 );			
					scene.add( tree );			
				}
			);		
		
			loader.load( 'models/tree/tree11114.obj', 'models/tree/tree11114.mtl', 
				function ( tree ) {
					tree.scale.set(2, 2, 2);
					tree.position.set( -5000, 0, -2000 );			
					scene.add( tree );			
				}
			);		
		
	

				
/*			



			
		
			
			
			loader.load( 'models/bridge/bridge3.obj', 'models/bridge/bridge3.mtl', 
				function ( bridge3 ) {
					bridge3.scale.set(1/2, 1/2, 2/3);
					bridge3.position.set( 1500, 0, 1400 );
					bridge3.rotation.y = -Math.PI/6;
					bridge3.rotation.x = Math.PI/6;
					bridge3.rotation.z = Math.PI/12;					
					scene.add( bridge3 );
				}
			);	

		
			loader.load( 'models/bench/Bench2.obj', 'models/bench/Bench2.mtl', 
				function ( Bench2 ) {

			var material = new THREE.MeshLambertMaterial( { color: 0xA0522D } );	
			
				Bench2.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							//child.material.map = texture;
							child.material = material;
						}

					} );

					
					Bench2.scale.set(1/10, 1/10, 1/10);
					Bench2.position.set( 2000, 25, -500 );
					Bench2.material = material;		
					//Bench2.rotation.y = Math.PI+Math.PI/3;	
					//Bench2.rotation.x = -Math.PI/36;						
					scene.add( Bench2 );
		

					var mesh = Bench2.clone();
					scene.add( mesh );
					mesh.position.set( 3000, 25, 0 );
									
			
				}
			);	

			
		

	

			

			loader.load( 'models/playground/playground.obj', 'models/playground/playground.mtl', 
				function ( playground ) {
					playground.scale.set(1/4, 1/4, 1/4);
					playground.position.set( -1000, 0, -5000 );	
					scene.add( playground );
				}
			);	
		
					
			loader.load( 'models/hexagonalBench/hexagonalBench.obj', 'models/hexagonalBench/hexagonalBench.mtl', 
				function ( hexagonalBench ) {
					hexagonalBench.scale.set(4, 4, 4);
					hexagonalBench.position.set( 2000, 0, -2000 );	
					scene.add( hexagonalBench );
				}
			);	
			
			



			

			loader.load( 'models/urn/urn.obj', 'models/urn/urn.mtl', 
				function ( urn ) {
					urn.scale.set(4, 4, 4);
					urn.position.set( 2500, 0, -500 );	
					scene.add( urn );
					
					var mesh = urn.clone();
					scene.add( mesh );
					mesh.position.set( 3500, 0, 0 );
					
					var mesh = urn.clone();
					scene.add( mesh );
					mesh.position.set( 4500, 0, 500 );	
					
					var mesh = urn.clone();
					scene.add( mesh );
					mesh.position.set( 5500, 0, 1000 );
		
					
				}
			);


/*
		
			

			loader.load( 'models/tree/tree1.obj', 'models/tree/tree1.mtl', 
				function ( tree ) {
					tree.scale.set(2, 2, 2);
					tree.position.set( -6000, 0, -2000 );			
					scene.add( tree );
					
					var mesh = tree.clone();
					scene.add( mesh );
					mesh.position.set( -6000, 0, -1000 );

					var mesh = tree.clone();
					scene.add( mesh );
					mesh.position.set( -6000, 0, 0 );
	
					var mesh = tree.clone();
					scene.add( mesh );
					mesh.position.set( -6000, 0, 1000 );


					
				}
			);	
			
			
			loader.load( 'models/tree/tree2.obj', 'models/tree/tree2.mtl', 
				function ( tree ) {
					tree.scale.set(3, 3, 3);
					tree.position.set( -1600, 300, -2000 );			
					scene.add( tree );
				}
			);	
			
			loader.load( 'models/tree/tree3.obj', 'models/tree/tree3.mtl', 
				function ( tree ) {
					tree.scale.set(3, 3, 3);
					tree.position.set( -2200, 300, -2000 );			
					scene.add( tree );
				}
			);	
	
			loader.load( 'models/fountain/fountain.obj', 'models/fountain/fountain.mtl', 
				function ( fountain ) {
					fountain.scale.set(2, 2, 2);
					fountain.position.set( -250, 0, -220 );	
					//scene.add( fountain );
				}
			);	
			
			loader.load( 'models/bridge/bridge.obj', 'models/bridge/bridge.mtl', 
				function ( bridge ) {
					//bridge.scale.set(1/2, 1/2, 1/2);
					bridge.position.set( 1500, 0, -1200 );	
					//scene.add( bridge );
				}
			);	
			
			loader.load( 'models/busStation/busStation.obj', 'models/busStation/busStation.mtl', 
				function ( busStation ) {
					busStation.scale.set(3, 3, 3);
					busStation.position.set( -6500, 100, 0 );	
					busStation.rotation.y = -Math.PI/2;					
					scene.add( busStation );
				}
			);		
	
			
  newmtl название_материала1   # Объявление очередного материала
  # Цвета
  Ka 1,000 1,000 0,000         # Цвет окружающего освещения (желтый)
  Kd 1,000 1,000 1,000         # Диффузный цвет (белый)
  # Параметры отражения
  Ks 0,000 0,000 0,000         # Цвет зеркального отражения (0;0;0 - выключен)
  Ns 10,000                    # Коэффициент зеркального отражения (от 0 до 1000)
  # Параметры прозрачности
  d 0,9                        # Прозрачность указывается с помощью директивы d
  Tr 0,9                       #   или в других реализациях формата с помощью Tr
  #Следующий материал
  newmtl название_материала2
  ...	

• map_Ka -  Текстура
• map_Kd -  Диффузная текстура
• map_Ks -  Specular
• map_Ns -  Specular highlight
• map_d - Alpha
• map_bump - название говорит само за себя Bump.
• map_Ke -  Emission - самосвечение (или собственное излучение).  
	*/		
			}

			//

	function signum( x ) {

		if ( x >= 0 ) { sig = 1 } else { sig = -1; }
		return sig;
	
	}
		
		
	function prism( vectors, H, sizeX, Count, texturePath, transparent, opacity, posY ) {	
				
			var bias = 0; var k0, absSize;
			var count = Count;
			
			for ( var i = 0; i < vectors.length-1; i++ ) {
			
				var vec1 = new THREE.Vector3();
					vec1.subVectors( vectors[i+1], vectors[i] );
	
				var vec2 = new THREE.Vector3( 1, 0, 0 ); var vec3 = new THREE.Vector3( 0, 1, 0 );
				var angle = vec1.angleTo( vec2 );
				
				var sign = signum( vec1.dot( vec3 ) );
				
				var len = vec1.length();
				

				var geometry = new THREE.PlaneBufferGeometry( len, H, 1, 1 );
				geometry.applyMatrix( new THREE.Matrix4().makeRotationY( -sign * angle ) );
				
				var texture = THREE.ImageUtils.loadTexture( texturePath );
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping; 
					texture.anisotropy = renderer.getMaxAnisotropy();

					if ( i == 0 ) { 
						k0 = len / ( count * sizeX ); 
						absSize =  k0 * sizeX;
					}
					else {
					
						count = len / ( k0 * sizeX );
						
					}
					
					texture.repeat.set( count, 1 );
					texture.offset.set( bias , 0 );	
				
				var material = new THREE.MeshLambertMaterial( { map: texture, side: THREE.DoubleSide, transparent: transparent, opacity: opacity } );
				var plane = new THREE.Mesh( geometry, material );
			
				plane.position.set( ( vectors[i].x + vectors[i+1].x ) / 2, posY, ( vectors[i].y + vectors[i+1].y ) / 2 );

				scene.add(plane);		

				var bias2 = ( len - Math.round( count ) * sizeX * k0 ) / absSize;
				bias = bias + bias2;
				
			}	
				
		}				
			
			
			
			
function urn_add() {

	var urn = new THREE.Object3D();
	var geometry = new THREE.CylinderGeometry( 
	100, 70, 180, 4, true, true );
	var material = new THREE.MeshPhongMaterial( 
		{ 
			color: 0xC0C0C0, 
			side: THREE.DoubleSide 
		} );
	var piramida = 
		new THREE.Mesh( geometry, material );
	piramida.rotation.y = Math.PI / 4;
	piramida.position.set( 0, 120, 0 );
	urn.add( piramida );

	var geometry = 
		new THREE.PlaneGeometry( 100, 100, 1, 1 );

	var plane = 
		new THREE.Mesh( geometry,  material );
	urn.add( plane );

	plane.position.set( 0, 30, 0 );
	plane.rotation.x = Math.PI / 2;

	var geometry = 
		new THREE.BoxGeometry( 5, 140, 20); 
	leg = new THREE.Mesh( geometry,  material );
	leg.position.set( -66, 70, 0 );
	urn.add( leg );

	leg2 = leg.clone();
	leg2.position.set( 66, 70, 0 );
	urn.add( leg2 );

	var geometry = 
		new THREE.PlaneGeometry( 10, 130, 1, 1 );
	mesh = new THREE.Mesh( geometry,  material );
	mesh.position.set( 0, 20, 0 );
	mesh.rotation.z = Math.PI / 2;
	mesh.rotation.x = Math.PI / 2;
	urn.add( mesh );

	var geometry = 
		new THREE.PlaneGeometry( 16, 150, 1, 1 );
	mesh2 = new THREE.Mesh( geometry,  material );

	mesh2.position.set( -66, 0, 0 );
	mesh2.rotation.x = Math.PI / 2;
	urn.add( mesh2 );

	mesh3 = mesh2.clone();
	mesh3.position.set( 66, 0, 0 );

	urn.add( mesh3 );

	urn.scale.set(2,2,2 );

	return  urn;

}			
			
	function addLine( x, y, z) {

			var geometry = new THREE.Geometry;
			var material = new THREE.LineBasicMaterial( { color: 0x8B4726 } );

			geometry.vertices.push( new THREE.Vector3( x, -1000, z ) ); 
			geometry.vertices.push( new THREE.Vector3( x, 1000, z ) ); 
			
			var line = new THREE.Line( geometry, material );
			scene.add( line );


	}	
			
			//return array with height data from img
			function getHeightData(img,scale) {
			  
			 if (scale == undefined) scale=1;
			  
				var canvas = document.createElement( 'canvas' );
				canvas.width = img.width;
				canvas.height = img.height;
				var context = canvas.getContext( '2d' );
			 
				var size = img.width * img.height;
				var data = new Float32Array( size );
			 
				context.drawImage(img,0,0);
			 
				for ( var i = 0; i < size; i ++ ) {
					data[i] = 0
				}
			 
				var imgd = context.getImageData(0, 0, img.width, img.height);
				var pix = imgd.data;
			 
				var j=0;
				for (var i = 0; i<pix.length; i +=4) {
					var all = pix[i]+pix[i+1]+pix[i+2];
					data[j++] = all/(12*scale);
				}
				 
				return data;
			}				
			
			
	function addModelToScene( geometry, materials ) 
{
			var material = new THREE.MeshFaceMaterial( materials );
			var model = new THREE.Mesh( geometry, material );
			model.scale.set(200,150,200);
			scene.add( model );
	
}			
			
        function initParticles( x, y, z, count ) {
        	particleGroup = new SPE.Group({
        		texture: THREE.ImageUtils.loadTexture('textures/smokeparticle.png'),
        		maxAge: 2
        	});

        	emitter = new SPE.Emitter({
        		position: new THREE.Vector3( x, y, z ),
                positionSpread: new THREE.Vector3( 0, 0, 0 ),

        		acceleration: new THREE.Vector3(0, -10, 0).multiplyScalar(50),
        		accelerationSpread: new THREE.Vector3( 10, 0, 10 ).multiplyScalar(50),

        		velocity: new THREE.Vector3(0, 15, 0).multiplyScalar(50),
        		velocitySpread: new THREE.Vector3(10, 7.5, 10).multiplyScalar(50),

        		colorStart: new THREE.Color('white'),
        		colorEnd: new THREE.Color('red'),
        		sizeStart: 50,
        		sizeEnd: 50,
				opacityStart: 1,
                opacityEnd: 1,
        		particleCount: count
        	});

        	particleGroup.addEmitter( emitter );
        	scene.add( particleGroup.mesh );

        	//document.querySelector('.numParticles').textContent =
        		//'Total particles: ' + emitter.particleCount;
        }			


		
	function CylindricalMesh( 
		Radius, Height, sgmRadius, sgmHeight, materials ) {

		var Cylinder = new THREE.Object3D();
		var geometry = new THREE.CylinderGeometry( Radius, Radius, 
		Height, sgmRadius, sgmHeight, true );
		var herd = new THREE.Mesh( geometry, materials[1] );
		Cylinder.add( herd );

		var obverse = new THREE.Mesh( new THREE.CircleGeometry( 
		Radius, sgmRadius ), materials[0] );	
		obverse.rotation.x = -Math.PI/2;					   
		obverse.position.y = Height / 2;
		Cylinder.add( obverse );
		EventsControls.attach( obverse );	
		return Cylinder;

}

CylindricalMesh.prototype = Object.create( CylindricalMesh.prototype );


	
			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				var time = performance.now() * 0.001;

				water.material.uniforms.time.value += 1.0 / 60.0;
				controls.update();
				EventsControls.update();
				EventsControlsObj.update();
				water.render();		
				
				renderParticle( clock.getDelta() );				
				renderer.render( scene, camera );

				if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
				
						videoImageContext.drawImage( video, 0, 0 );
						if ( videoTexture ) 
							videoTexture.needsUpdate = true;
				}			
				

			}
			
			function renderParticle( dt ) {
				particleGroup.tick( dt );
			}

			function grayBuildings() {
			
					vectors[0] = new THREE.Vector3(236,274);
					vectors[1] = new THREE.Vector3(266,253);
					vectors[2] = new THREE.Vector3(244,217);
					vectors[3] = new THREE.Vector3(280,194);
					vectors[4] = new THREE.Vector3(306,231);
					vectors[5] = new THREE.Vector3(335,211);
					vectors[6] = new THREE.Vector3(321,178);
					vectors[7] = new THREE.Vector3(355,159);
					vectors[8] = new THREE.Vector3(388,212);
					vectors[9] = new THREE.Vector3(360,231);
					vectors[10] = new THREE.Vector3(375,264);
					vectors[11] = new THREE.Vector3(339,284);
					vectors[12] = new THREE.Vector3(321,254);
					vectors[13] = new THREE.Vector3(280,279);
					vectors[14] = new THREE.Vector3(298,313);
					vectors[15] = new THREE.Vector3(260,336);
					vectors[16] = new THREE.Vector3(237,306);
					vectors[17] = new THREE.Vector3(210,321);
					vectors[18] = new THREE.Vector3(176,268);
					vectors[19] = new THREE.Vector3(212,243);

				var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 20; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();
				

					
				var heightShore = 40, amount = 1060;
				var extrudeSettings = { 
					amount: amount, 
					bevelSegments: 8, 
					curveSegments: 32,
					bevelEnabled: false
				};
				
				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );			
				var mesh = new THREE.Mesh(geometry, material);
				mesh.rotation.x = -Math.PI/2;
				scene.add(mesh);			

				
				
				
				
					vectors[0] = new THREE.Vector3(-102,272,0);
					vectors[1] = new THREE.Vector3(-41,378,0);
					vectors[2] = new THREE.Vector3(-80,405,0);
					vectors[3] = new THREE.Vector3(-22,510,0);
					vectors[4] = new THREE.Vector3(-77,509,0);
					vectors[5] = new THREE.Vector3(-126,430,0);
					vectors[6] = new THREE.Vector3(-134,435,0);
					vectors[7] = new THREE.Vector3(-195,328,0);
	
				var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 8; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();

				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );
				var mesh = new THREE.Mesh(geometry, material);
				mesh.rotation.x = -Math.PI/2;
				scene.add(mesh);	

					vectors[0] = new THREE.Vector3(-102,272,0);
					vectors[1] = new THREE.Vector3(-41,378,0);
					vectors[2] = new THREE.Vector3(-80,405,0);
					vectors[3] = new THREE.Vector3(-22,510,0);
					vectors[0] = new THREE.Vector3(21,-239,0);
					vectors[1] = new THREE.Vector3(11,-243,0);
					vectors[2] = new THREE.Vector3(-10,-230,0);
					vectors[3] = new THREE.Vector3(-14,-237,0);
					vectors[4] = new THREE.Vector3(-25,-230,0);
					vectors[5] = new THREE.Vector3(-29,-212,0);
					vectors[6] = new THREE.Vector3(-17,-187,0);
					vectors[7] = new THREE.Vector3(0,-183,0);
					vectors[8] = new THREE.Vector3(11,-189,0);
					vectors[9] = new THREE.Vector3(13,-196,0);
					vectors[10] = new THREE.Vector3(42,-212,0);
					vectors[11] = new THREE.Vector3(49,-230,0);
					vectors[12] = new THREE.Vector3(61,-228,0);
					vectors[13] = new THREE.Vector3(86,-310,0);
					vectors[14] = new THREE.Vector3(111,-305,0);
					vectors[15] = new THREE.Vector3(125,-346,0);
					vectors[16] = new THREE.Vector3(153,-362,0);
					vectors[17] = new THREE.Vector3(159,-353,0);
					vectors[18] = new THREE.Vector3(178,-367,0);
					vectors[19] = new THREE.Vector3(175,-387,0);
					vectors[20] = new THREE.Vector3(166,-400,0);
					vectors[21] = new THREE.Vector3(152,-411,0);
					vectors[22] = new THREE.Vector3(134,-403,0);
					vectors[23] = new THREE.Vector3(139,-394,0);
					vectors[24] = new THREE.Vector3(110,-379,0);
					vectors[25] = new THREE.Vector3(100,-389,0);
					vectors[26] = new THREE.Vector3(86,-344,0);
					vectors[27] = new THREE.Vector3(68,-333,0);
					vectors[28] = new THREE.Vector3(0,-346,0);
					vectors[29] = new THREE.Vector3(-11,-294,0);
					vectors[30] = new THREE.Vector3(31,-276,0);

				var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 31; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();

				var extrudeSettings = { 
					amount: 1060, 
					bevelSegments: 8, 
					curveSegments: 32, 
					material: 0, 
					extrudeMaterial: 1 
				};		
						
				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );
				
				var Texture = new THREE.ImageUtils.loadTexture( 'textures/svetloe/lenina64.jpg' );
				Texture.wrapS = Texture.wrapT = THREE.RepeatWrapping;
				Texture.repeat.set( ( 1 / 256 ) / 4 , ( 1 / 128)  / 8 );
				var extrMaterial = new THREE.MeshBasicMaterial({
					map: Texture
				});				
				
				var materials = [ material, extrMaterial];
				//var material = new THREE.MeshFaceMaterial(materials);

				
				var lenina64 = new THREE.Mesh(geometry, material);
				lenina64.rotation.x = -Math.PI/2;
				scene.add(lenina64);	
				
					vectors[0] = new THREE.Vector3(200,-304,0);
					vectors[1] = new THREE.Vector3(188,-322,0);
					vectors[2] = new THREE.Vector3(210,-336,0);
					vectors[3] = new THREE.Vector3(223,-319,0);

				var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 4; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();

				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );		
				var mesh = new THREE.Mesh(geometry, material);

				mesh.rotation.x = -Math.PI/2;
				scene.add(mesh);					
	
					vectors[0] = new THREE.Vector3(228,128,0);
					vectors[1] = new THREE.Vector3(216,108,0);
					vectors[2] = new THREE.Vector3(245,91,0);
					vectors[3] = new THREE.Vector3(257,111,0);
				var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 4; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();

				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );				
				var mesh = new THREE.Mesh(geometry, material);

				mesh.rotation.x = -Math.PI/2;
				scene.add(mesh);	
	
					vectors[0] = new THREE.Vector3(-285,6,0);
					vectors[1] = new THREE.Vector3(-267,6,0);
					vectors[2] = new THREE.Vector3(-267,42,0);
					vectors[3] = new THREE.Vector3(-286,42,0);	

				var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 4; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();

				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );
				var mesh = new THREE.Mesh(geometry, material);

				mesh.rotation.x = -Math.PI/2;
				scene.add(mesh);	

					vectors[0] = new THREE.Vector3(350,-267,0);
					vectors[1] = new THREE.Vector3(369,-235,0);
					vectors[2] = new THREE.Vector3(510,-316,0);
					vectors[3] = new THREE.Vector3(510,-359,0);

				var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 4; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();

				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );
				
				var mesh = new THREE.Mesh(geometry, material);
				mesh.rotation.x = -Math.PI/2;
				scene.add(mesh);	
	
					//
					
					vectors[0] = new THREE.Vector3(432,-126,0);
					vectors[1] = new THREE.Vector3(450,-94,0);
					vectors[2] = new THREE.Vector3(510,-127,0);
					vectors[3] = new THREE.Vector3(510,-175,0);

	
				var shape = new THREE.Shape(); 
				shape.moveToVector( vectors[0].multiplyScalar( scale ) );
				
				for ( var i = 1; i < 4; i++ ) {

					shape.lineToVector( vectors[i].multiplyScalar( scale ) );
				}
						shape.closePath();

				var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var material = new THREE.MeshLambertMaterial( { color: 0xA9A9A9 } );	
				var mesh = new THREE.Mesh(geometry, material);

				mesh.rotation.x = -Math.PI/2;
				scene.add(mesh);
		
			
			}
			

		</script>
	</body>
</html>
